<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Dynamic City Exploration Game with Hand Control</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <!-- Leaflet CSS -->
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet/dist/leaflet.css"
  />

  <!-- Leaflet JavaScript -->
  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>

  <!-- ml5.js Library -->
  <script src="https://unpkg.com/ml5@0.6.1/dist/ml5.min.js"></script>

  <style>
    body, html, #map {
      height: 100%;
      margin: 0;
      padding: 0;
    }

    #controls {
      position: absolute;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 1000;
      background: rgba(255, 255, 255, 0.9);
      padding: 10px 20px;
      border-radius: 8px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.3);
    }

    #status {
      position: absolute;
      bottom: 10px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 1000;
      background: rgba(255, 255, 255, 0.9);
      padding: 10px 20px;
      border-radius: 8px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.3);
      font-family: Arial, sans-serif;
      font-size: 14px;
      text-align: center;
    }

    /* Custom player marker styling */
    .player-marker {
      width: 20px;
      height: 20px;
      background-color: red;
      border: 2px solid white;
      border-radius: 50%;
      box-shadow: 0 0 3px rgba(0,0,0,0.5);
    }

    /* New: Custom win marker styling (Green Triangle) */
    .win-marker {
      width: 0;
      height: 0;
      border-left: 10px solid transparent;
      border-right: 10px solid transparent;
      border-bottom: 20px solid green;
      transform: rotate(180deg); /* Pointing upwards */
    }

    /* Video and Canvas styling */
    #videoContainer {
      position: absolute;
      bottom: 10px;
      right: 10px;
      width: 160px;
      height: 120px;
      z-index: 1000;
      border: 2px solid #ccc;
      border-radius: 8px;
      overflow: hidden;
      background: #000;
    }

    #video {
      width: 100%;
      height: 100%;
      transform: scaleX(-1); /* Mirror the video for natural interaction */
    }

    #overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none; /* Allow clicks to pass through */
    }
  </style>
</head>
<body>

  <div id="controls">
    <button onclick="startGame()" style="padding: 8px 16px; font-size: 16px;">Start Game</button>
  </div>

  <div id="status">Press "Start Game" to begin.</div>

  <div id="videoContainer">
    <video id="video" autoplay muted playsinline></video>
    <canvas id="overlay"></canvas>
  </div>

  <div id="map"></div>

  <script>
    // Initialize the map
    let map;
    let playerMarker;
    let targetMarker;
    let winMarker; // New: Marker for the win target
    let nodes = {};
    let edges = {};
    let currentNodeId;
    let targetNodeId;
    let winNodeId; // New: Node ID for the win target
    let loadedAreas = [];
    let loadingData = false;
    const dataFetchThreshold = 0.002;
    let isMoving = false;

    // Handpose variables
    let videoElement;
    let canvasElement;
    let ctx;
    let handposeModel;
    let predictions = [];
    let currentZone = 'center';
    let lastMoveTime = 0;

    // Cooldown to prevent rapid movements
    const MOVE_COOLDOWN = 500; // milliseconds

    // Win condition radius in meters
    const WIN_RADIUS = 10; // Adjust as needed

    // Initialize the map
    function initMap() {
      const center = [50.7220, -1.8667]; // Example: London coordinates
      map = L.map('map').setView(center, 16);

      // Add OpenStreetMap tile layer
      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: '© OpenStreetMap contributors',
      }).addTo(map);
    }

    // Fetch street data from OpenStreetMap
    function fetchStreetData(bbox, callback) {
      const query = `
        [out:json][timeout:25];
        (
          way["highway"](${bbox.join(',')});
          >;
        );
        out body;
      `;

      fetch('https://overpass-api.de/api/interpreter', {
        method: 'POST',
        body: query,
        headers: {
          'Content-Type': 'application/x-www-form-urlencoded'
        },
      })
      .then(response => response.json())
      .then(data => callback(data))
      .catch(error => {
        console.error('Error fetching OSM data:', error);
      });
    }

    // Check if a point is within a bounding box
    function isPointInBBox(lat, lon, bbox) {
      return lat >= bbox[0] && lat <= bbox[2] && lon >= bbox[1] && lon <= bbox[3];
    }

    // Check if the player is near the edge of the loaded area
    function checkPlayerPosition() {
      const playerNode = nodes[currentNodeId];
      const currentBBox = loadedAreas[loadedAreas.length - 1];

      const { lat, lon } = playerNode;
      const buffer = dataFetchThreshold;

      if (
        lat - buffer <= currentBBox[0] ||
        lat + buffer >= currentBBox[2] ||
        lon - buffer <= currentBBox[1] ||
        lon + buffer >= currentBBox[3]
      ) {
        loadAdditionalData(lat, lon);
      }
    }

    // Load additional data when player nears the edge
    function loadAdditionalData(lat, lon) {
      if (loadingData) return;
      loadingData = true;

      const bboxSize = 0.01;
      const bbox = [
        lat - bboxSize / 2,
        lon - bboxSize / 2,
        lat + bboxSize / 2,
        lon + bboxSize / 2,
      ];

      if (loadedAreas.some(area => isBBoxEqual(area, bbox))) {
        loadingData = false;
        return;
      }

      fetchStreetData(bbox, osmData => {
        processStreetData(osmData);
        loadedAreas.push(bbox);
        loadingData = false;
      });
    }

    // Utility function to compare bounding boxes
    function isBBoxEqual(bbox1, bbox2) {
      return bbox1.every((val, index) => val === bbox2[index]);
    }

    // Process OSM data into nodes and edges
    function processStreetData(osmData) {
      const existingNodeIds = new Set(Object.keys(nodes));

      osmData.elements.forEach(element => {
        if (element.type === 'node' && !nodes[element.id]) {
          nodes[element.id] = { id: element.id, lat: element.lat, lon: element.lon, neighbors: [] };
        }
      });

      osmData.elements.forEach(element => {
        if (element.type === 'way') {
          const nodeRefs = element.nodes;
          for (let i = 0; i < nodeRefs.length - 1; i++) {
            const from = nodeRefs[i];
            const to = nodeRefs[i + 1];

            if (!edges[from]) edges[from] = [];
            if (!edges[to]) edges[to] = [];

            edges[from].push(to);
            edges[to].push(from);

            if (nodes[from] && nodes[to]) {
              if (!nodes[from].neighbors.includes(to)) {
                nodes[from].neighbors.push(to);
              }
              if (!nodes[to].neighbors.includes(from)) {
                nodes[to].neighbors.push(from);
              }

              // Draw the street segments if not already drawn
              if (!existingNodeIds.has(from) || !existingNodeIds.has(to)) {
                L.polyline(
                  [
                    [nodes[from].lat, nodes[from].lon],
                    [nodes[to].lat, nodes[to].lon],
                  ],
                  { color: 'blue', weight: 2 }
                ).addTo(map);
              }
            }
          }
        }
      });

      // Place player and target if not already placed
      if (!playerMarker) {
        placePlayer();
        setupHandpose();
      }
    }

    // Place player and target on the map
    function placePlayer() {
      const nodeIds = Object.keys(nodes);
      if (nodeIds.length === 0) {
        console.error('No nodes available to place the player.');
        return;
      }

      currentNodeId = nodeIds[Math.floor(Math.random() * nodeIds.length)];
      targetNodeId = nodeIds[Math.floor(Math.random() * nodeIds.length)];
      winNodeId = nodeIds[Math.floor(Math.random() * nodeIds.length)]; // New: Select win node

      // Create custom circular icon for player
      const playerIcon = L.divIcon({
        className: 'player-marker',
      });

      playerMarker = L.marker([nodes[currentNodeId].lat, nodes[currentNodeId].lon], {
        title: 'Player',
        icon: playerIcon,
      }).addTo(map);

      // Create target marker
      targetMarker = L.marker([nodes[targetNodeId].lat, nodes[targetNodeId].lon], {
        title: 'Destination',
        icon: L.icon({
          iconUrl: 'https://leafletjs.com/examples/custom-icons/leaf-green.png',
          iconSize: [38, 95],
          iconAnchor: [22, 94],
          popupAnchor: [-3, -76],
        }),
      }).addTo(map);

      // New: Create win marker (Green Triangle)
      const winIcon = L.divIcon({
        className: 'win-marker',
        iconSize: [20, 20], // Adjust size as needed
        iconAnchor: [10, 10], // Center the icon
      });

      winMarker = L.marker([nodes[winNodeId].lat, nodes[winNodeId].lon], {
        title: 'Win Destination',
        icon: winIcon,
      }).addTo(map);

      map.setView([nodes[currentNodeId].lat, nodes[currentNodeId].lon], 17);
      document.getElementById('status').textContent = 'Use your palm to navigate. Reach the destination!';
    }

    // Animate marker movement along the path
    function animateMovement(startLatLng, endLatLng, duration, callback) {
      const startTime = performance.now();

      function animate(currentTime) {
        const elapsed = currentTime - startTime;
        const progress = Math.min(elapsed / duration, 1);

        const currentLat = startLatLng.lat + (endLatLng.lat - startLatLng.lat) * progress;
        const currentLng = startLatLng.lng + (endLatLng.lng - startLatLng.lng) * progress;

        playerMarker.setLatLng([currentLat, currentLng]);
        map.panTo([currentLat, currentLng], { animate: false });

        if (progress < 1) {
          requestAnimationFrame(animate);
        } else if (callback) {
          callback();
        }
      }

      requestAnimationFrame(animate);
    }

    // Handle player movement based on direction
    function handleMovement(direction) {
      if (isMoving) return;

      if (!currentNodeId || !nodes[currentNodeId]) {
        console.error('Player position is not initialized.');
        return;
      }

      const neighbors = nodes[currentNodeId].neighbors;
      if (neighbors.length === 0) return;

      const currentNode = nodes[currentNodeId];
      let nextNodeId = null;
      let minAngleDiff = Infinity;

      // Define direction angles in radians
      const directionAngles = {
        'left': Math.PI,
        'up': -Math.PI / 2,
        'right': 0,
        'down': Math.PI / 2
      };

      const directionAngle = directionAngles[direction];
      if (directionAngle === undefined) return;

      // Find the neighbor closest to the desired direction
      neighbors.forEach(neighborId => {
        const neighbor = nodes[neighborId];
        const dx = neighbor.lon - currentNode.lon;
        const dy = neighbor.lat - currentNode.lat;
        const angle = Math.atan2(dy, dx);

        let angleDiff = Math.abs(angle - directionAngle);
        if (angleDiff > Math.PI) angleDiff = 2 * Math.PI - angleDiff;

        if (angleDiff < minAngleDiff) {
          minAngleDiff = angleDiff;
          nextNodeId = neighborId;
        }
      });

      if (nextNodeId) {
        isMoving = true;
        const nextNode = nodes[nextNodeId];
        const startLatLng = L.latLng(currentNode.lat, currentNode.lon);
        const endLatLng = L.latLng(nextNode.lat, nextNode.lon);

        animateMovement(startLatLng, endLatLng, 500, () => {
          currentNodeId = nextNodeId;
          isMoving = false;
          checkWinCondition();
          checkPlayerPosition();
        });
      }
    }

    // Move player if enough time has passed
    function movePlayer(direction) {
      const now = Date.now();

      if (now - lastMoveTime > MOVE_COOLDOWN) {
        lastMoveTime = now;
        handleMovement(direction);
      }
    }

    // Set up the handpose model
    function setupHandpose() {
      videoElement = document.getElementById('video');
      canvasElement = document.getElementById('overlay');
      ctx = canvasElement.getContext('2d');

      navigator.mediaDevices.getUserMedia({ video: true })
        .then(stream => {
          videoElement.srcObject = stream;
          videoElement.play();

          videoElement.onloadeddata = () => {
            canvasElement.width = videoElement.videoWidth;
            canvasElement.height = videoElement.videoHeight;

            handposeModel = ml5.handpose(videoElement, modelReady);

            handposeModel.on('predict', results => {
              predictions = results;
            });
          };
        })
        .catch(err => {
          console.error('Error accessing webcam: ', err);
          document.getElementById('status').textContent = 'Error accessing webcam. Please allow camera access.';
        });
    }

    function modelReady() {
      console.log('Handpose model ready!');
      processHandData();
    }

    // Process hand data and control movement
    function processHandData() {
      ctx.clearRect(0, 0, canvasElement.width, canvasElement.height);

      if (predictions.length > 0) {
        const prediction = predictions[0];
        const landmarks = prediction.landmarks;

        drawHand(landmarks);
        // const palmPosition = landmarks[0]; // Wrist position (No longer used)

        // **New Implementation for Palm Tilt Detection**
        detectPalmTilt(landmarks);
      }

      requestAnimationFrame(processHandData);
    }

    // Function to detect palm tilt and determine direction
    function detectPalmTilt(landmarks) {
      // Extract necessary landmarks
      const wrist = landmarks[0];
      const middleFingerTip = landmarks[12]; // Landmark 12 is the tip of the middle finger

      // Calculate differences
      const deltaX = wrist[0] - middleFingerTip[0]; // Invert X-axis due to mirrored video
      const deltaY = middleFingerTip[1] - wrist[1]; // Adjust Y-axis for correct direction

      // Calculate angle in degrees
      const angleRad = Math.atan2(deltaY, deltaX);
      let angleDeg = angleRad * (180 / Math.PI);

      // Normalize angle to [0, 360)
      if (angleDeg < 0) {
        angleDeg += 360;
      }

      // Define angle thresholds for directions
      // Adjust these thresholds as needed based on testing
      const directionThresholds = {
        'up': { min: 45, max: 135 },
        'right': { min: 315, max: 360 },
        'right_ext': { min: 0, max: 45 }, // Combining for right
        'down': { min: 225, max: 315 },
        'left': { min: 135, max: 225 }
      };

      let detectedDirection = null;

      if (angleDeg >= directionThresholds['up'].min && angleDeg < directionThresholds['up'].max) {
        detectedDirection = 'up';
      } else if (
        (angleDeg >= directionThresholds['right'].min && angleDeg < directionThresholds['right'].max) ||
        (angleDeg >= directionThresholds['right_ext'].min && angleDeg < directionThresholds['right_ext'].max)
      ) {
        detectedDirection = 'right';
      } else if (angleDeg >= directionThresholds['down'].min && angleDeg < directionThresholds['down'].max) {
        detectedDirection = 'down';
      } else if (angleDeg >= directionThresholds['left'].min && angleDeg < directionThresholds['left'].max) {
        detectedDirection = 'left';
      }

      // Debugging: Display angle and direction
      // Uncomment the following line to see the angle and direction on the canvas
      // ctx.fillText(`Angle: ${Math.round(angleDeg)}°, Dir: ${detectedDirection || 'None'}`, 10, 20);

      if (detectedDirection) {
        movePlayer(detectedDirection);
      }
    }

    function drawHand(landmarks) {
      ctx.strokeStyle = 'red';
      ctx.lineWidth = 2;

      // Define finger connections
      const fingers = [
        [0, 1, 2, 3, 4],     // Thumb
        [0, 5, 6, 7, 8],     // Index finger
        [0, 9, 10, 11, 12],  // Middle finger
        [0, 13, 14, 15, 16], // Ring finger
        [0, 17, 18, 19, 20]  // Pinky
      ];

      // Draw finger lines
      fingers.forEach(finger => {
        for (let i = 0; i < finger.length - 1; i++) {
          const start = landmarks[finger[i]];
          const end = landmarks[finger[i + 1]];

          ctx.beginPath();
          ctx.moveTo(start[0], start[1]);
          ctx.lineTo(end[0], end[1]);
          ctx.stroke();
        }
      });

      // Draw landmarks
      landmarks.forEach(point => {
        ctx.beginPath();
        ctx.arc(point[0], point[1], 4, 0, 2 * Math.PI);
        ctx.fillStyle = 'red';
        ctx.fill();
      });
    }

    // **New: Function to check win condition based on proximity to winMarker**
    function checkWinCondition() {
      // Existing condition: Reached targetNodeId
      if (currentNodeId === targetNodeId) {
        // Stop processing hand data
        predictions = [];
        document.getElementById('status').textContent = 'You have reached your destination! Game Over.';
        return;
      }

      // New condition: Reached winNodeId within WIN_RADIUS meters
      const playerLatLng = playerMarker.getLatLng();
      const winLatLng = winMarker.getLatLng();

      const distance = playerLatLng.distanceTo(winLatLng); // Distance in meters

      if (distance <= WIN_RADIUS) {
        // Stop processing hand data
        predictions = [];
        document.getElementById('status').textContent = 'Congratulations! You have reached the win destination! Game Over.';
        // Optionally, you can remove the winMarker or perform other actions
        // map.removeLayer(winMarker);
      }
    }

    // Start the game
    function startGame() {
      // Reset variables
      nodes = {};
      edges = {};
      loadedAreas = [];
      if (playerMarker) {
        map.removeLayer(playerMarker);
        playerMarker = null;
      }
      if (targetMarker) {
        map.removeLayer(targetMarker);
        targetMarker = null;
      }
      if (winMarker) { // New: Remove existing winMarker if any
        map.removeLayer(winMarker);
        winMarker = null;
      }
      isMoving = false;
      currentZone = 'center';
      lastMoveTime = 0;
      predictions = [];

      // Remove existing polyline layers
      map.eachLayer(layer => {
        if (layer instanceof L.Polyline || layer instanceof L.Marker) {
          map.removeLayer(layer);
        }
      });

      // Add tile layer back
      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: '© OpenStreetMap contributors',
      }).addTo(map);

      // Fetch initial street data
      const center = map.getCenter();
      const bboxSize = 0.01;
      const bbox = [
        center.lat - bboxSize / 2,
        center.lng - bboxSize / 2,
        center.lat + bboxSize / 2,
        center.lng + bboxSize / 2,
      ];

      fetchStreetData(bbox, osmData => {
        processStreetData(osmData);
        loadedAreas.push(bbox);
      });

      document.getElementById('status').textContent = 'Loading map...';
    }

    // Initialize the map on window load
    window.onload = function () {
      initMap();
    };
  </script>
</body>
</html>
